<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #0F0;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #0F0;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #000;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Naughty Words"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Don't forget me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="UnHIDE" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b110950ba2a084e7f3e711031d2bb397573b2f65e9ec5b3944d78e0b7f1a135a4ff932987bba76076bd3eaf218b1e3f432d7b01b0bbe89faefcae789b9f0e14fb1529afb899eb27f3004b8b51231b5ff4f9d02243bb8c4b0350a63a915041d71108082c12527a4c63103838f1f3a0120eb278130784e0c0fdb377c20deea807e5cf0aac743dfb373132235df53cb552be2f51aba07622ec5f04c3baaaa52eb2befc51612c35e200cc44f1002cdbaea8942df0cb6ac173c5c00a40cb8b2371088a47ac7d98a60dcceaefa759ad8b00cf5d09d16188380f87af026485c21b51607a6aed128f5689b9b68aef6ec70070a7653ca09be9695c267bb1619afc861254fb166c40f85e771d09fcff9386789d5a8ce75ae841b013dd6779fc970e243fac26826208cf3d3020655c8097429bad13118075a36fbc97e7082ec3bd2f02a52eb23b3a5df55522bae7a7666520cec2342ec1d5752b50c5eef425ae58ef02a2cf76c93bb3daa313bd154d89b14e2824fc2c7a522506adf0a6a1ca22a9787342cefc87215a431e2fe4e0ebe003c28d3dd7f688e6fa4f13ba6c8d871069591b02f85d7ab6af39b0e6d8fa243dd35e3edf5a113ede0620e409af6757d529fae7fe693f409de077386112ed6877ec97f5af52943a1fee30b2b2c9969841103ed21be26831b15bccacd2916b4cf6077267e26e2f5eeaa068936ab4e96c1a5d4ad6e300a259d194a911166cce8e3aedc0142028e790daa3338980465bed90401ec83ab92b4de26ce4647d1c71e53f60491b41ba8efee3f58a930e4eb39406ae940a19d588f446c7ce0069057d266c7070e0f571de390c4dc6c1211f01878972ba191991819d70f9047002e818af5d557e5264efbbf9b616085e9c6ce46c6373b84daf9e9ceaa40088434fe3063023ba663a52b2e8c4f9ef03c7cb3033ae0d8e10596bc34c3f7cefdeccba2323003239cdecb33618da091db7fb9565f1cf2b5f312cb2914c28338c375dcdae62ede2e69d75a5a2c4701f15cca21c03fb06af6079003ff44b28f9f9f662a33dce3d41541b8dc55a443a975d20fa33a54a2339edd53578923dbdae213b982d10115d392606377a11ed59312424be0983b8e889ed10221c4bc5a3c80bd7983606ea2edee03da6732f1baa616227ce0d2d816b8c18a61cc118d3120cea08b02b5e02bc20128e87f57e10c48cb6e27ff44a317b8e668dcfbf945eceed2d34f2a30c611d4f8008cd910156be5fb107aef0dba1942426e4a84ae8550023ded2bbdb7ab271c1ba5398b44fe9641ef621f1e8684f2e8bae68d6f7342bab8f3ceff49d078d5566cdea47c776cdc42f92ce78295132d72e5534e960bfe38d652f79a11fcbdb817be412ec766f62a78962b5b16813f498cb54b3d7ef1b1c37cd87ee45e3ea17963f73cefb1e8deafb7575bbd24b154c46bf9b45a68d7f856cd6c46b097b634d3e6f94863c802b6bf675ff3785145e820b2e082df29375828d233d6d68c42519c645e780d24c75ee7f40401a2ec2b0839e1f91f3e0ff7d42e34727dd987b27d22b59ab5658baa1d944a4519a963138b306361acc91eeb027e137da84bb78318d4f6f3ce8578876ecc49ec6083e7667843a6ad267e627a28c680c58717a7983ec317f02d02b556bdb18e696d04215ab2159eae68dfb6d4c9665c62eabe6666bad19de7207327c6968a45377c3a1c02056f7cd733e09e1d2d21cbea258e42ccbbfa56cfa61f93e464d27277eb0b38764aaa9a81b5276af34293f0c44c8f50bb77479d4b8b285a7fb5bd555105def977b39a3d0144333e0c3f8081f8138c68fbab858ab72b6580ead947d01de9ca07978de0810e3140caaf6abffa0d20a9436a5516510ac30f64d87c8e2bde7616788d374492eebfc28e673130d9b6c256c5a1bede7cb6680c439ac4c731f5ffa88ec5a4444800cd4b36e8e8f04b05fe78dae853ecf7e68a1f6d49e7292689dc4d6ed80306f3d02c40eac814e84d5adfb18bb633e9a44f6bb881001d965b047ced3f2c1d6d0041ba121db27b500d8d302bb99c075105c62ee57d2a2700e3ebb3a6a58d5ab113ff233cc7eb24c6e00ccd8e3ae8690fe4423244a0b402a2537c552953fbe0264c02a0e969070b64e45424eed4c6232a1c2e3208ea15c4d749a24235630e470b79b08564862e318e29cfe5e3e06a583ca416819ffdc04a7d7970a283f8068dd6cac2164702d3b83d7ab74e5e429cfa86d5702171f187edb5d8d43857d39e493787cedba58f429b8c988c51fcbf34942fa7c7ca7fd1a22d149bd4daeb8efe50fd8a06e5fff7943a06f167a2ac997814736ec16ea1d9bb3f9b5c693827c24a7373bc83d002afa3386e328b6395f30ef6b72724497cab2cedf498b025266449f2df5e3b74a3f68a3eb6fa60ccfa554932ef2b880eafb4501b6ea1c46357f8e94c917a6fcf16b50a9eefeb2c9cb2494c9dc370578425865e4540871fb3b71519d6b26b9655e59776cadc2b2fb6fc4fd48ab1df03f9dd53d9a0c42b6b52644a49ac0bd1fc46213f3395e3c88a01513eb9854fcb6d23d595ffc0e676174f7da8bd3948785b42310f32e0e5a68d25691ed0fb379d16ddd796f7b63d7aaa7b8e62ea4dbd4ed01c2b46ded76a6308336ff89d27f6d52177643b375fc5ef3b46938f9eceab173c2653484fc4490ecaf478f7534a656925f962ae916048b605f06bf88c03ac94745fc3ef6773ca1f56e63e79bf8d342ffb8fe0f334e6e263cd868a94ccb007c393d1a6198f7e1c7c2cf4929ed71a4b08d0abf9ccc537be17c947be4f017f8ca3921d95a81965b9c342043b4da87d9d00c9b292b82e12f5cc03d8bb03f850d424e8dd360b825b271ba2e24b7790df5b5c4604c6c2cc7e78d54a78c10fd8648ec907546a1779a6d1bdb2c987bf842bde2bff07396e4043d5ef8bba5c85c1a1d8f763ab2ea3d01d5e57d1ee276c06c089af9a5dbcbba63ffaf21770b53b7a52a2e6135d1bb7e635067480676981144639fceede06a06dec85845b903631b793a276c2712f75485b054f5429f0cd8bcea6d601032b1b653c5029fa1d50c9148f89a35afbf8a9509c99b23bc62a5a5a80b70fc723fbe8104ae30b771048f0affde1cc2a8cf40fa0f8bcde0a729011c96eb5115a1410f860739b256ea2f71d800f3f5a1951f2914c14a326d6c4bd836cd5a8d091d6602005adff8180a2f9fb9525750dcc3e4758a052b8936f6c8f621d80b7fba3b1980beadf474386a1a0251c1fe1627f95732f8293800863511a0ea3540db218da9c632868007d03039a0c7dfc60a9f7b1a3c96ba22f9630fde06b9b4b35dc6d9f20a3d1194c05955b89f4158e81df43e1f2e944a742c4b7ad24bb2b2b170887dad1ed728092060e4d86fb782ac0ec03563a8db2a097c40be16fa89287ebda457cc519063f276dc2cc8ffa3475c33acc143bc7e5f6b965d7a965ca79c01d60ca7ab1bcfe778416622ac686db0948a00f01b31f4c4289d7a35031e0c542cb2edda457adc9249dd0d957a185eafd4f3f1e6107ba00268d71cc6c8b94d3b343b7c65fe6b6167276c54c2772264039db359a1c7fd7f4664f5936077480bf85affef70605cc291ef64082360cd564f8503e5ec95b7e47eaf9d4203e89e2390d9fcde725f633ddcfb0fbbd76d94774b0bf5100eb547b3cf311e9c43edec544835346632741945fc9a89d55eb6654bccda0ac18fae1026d35d07d3c8b2d90a24aba14e3a27058b2b2c17fa7fe08b73bb5af5c3b913d3646372adad9cd0ef3bfdba00e3dc8e39d53ff051fd6337c882cd18d525291245248c5251424863d7cd80a1f07ca73703eadef3c634912c04808147d8ddf2717eef53299817cb284a9d9471532c38f4fce0b2e33b080598ec6a202118f72b65ce6d6afd1bf28eb29c2bef380ea5884a371f8cc50c89357ce7417ca629d15a09901cdf53cb13991cc89c943414ed85db3d4c8cb3b329e543e900e46632c478e2d4dd9dea9e9fc23a513ce9f61ec4bf4db84b35c21286f5e9364e599038f96db2a3834f06228d65f3047d75a031f0d42195e026b8b6bc6751f80c21f9b3c57ded28ef76841ec6aa4048caf59c1216e8a0c90bc342f56d85832be233a5d4f29b49a855ba182375bcf94fbf29c8e94faf554ef19d51ee5893c29e0667fecda48b9b3a731b34b2d81c88bcbdb42fe38661011e94e47e0f52a98a9f8153247f38df032ae73b0d2fa068740c68d085baf53e9827acd613db8c62cfb49bb2ae19130c6c93901873475c5733d75e9efcaad2bef392ce2e8a972ea0fe378c89647053d4a1232afced7c8fae544eca6a7d7e78db9dd1061406d928865b31aac2d78a92a7c9a77ffbe782a2c4f44e7940bf0d8fadf41b0eee7ddc586c817f44adb6fb6cadf23360b359e4efa5c0f15a51fda2a682cf59764656977ab7eef125585e58623530a3706ceee4bd8049ccbb9135ebba90395f5658531b9a1e6e874f632db5301d265c3a3c4b53003bc6642df819dad7b9e4c83527c95cde6f8f33f643cdefa5b83badd6efdfb9dfe35dd1f278b00a905fa0e8af03d6c17eb8a248547d479027c1890efd661853663450e60d9a06cc969b247a10a0daebf0d9d19a88439faf4d64d383b8fa9acd9e2d42d9c43d18b6ab8b4574eca7710e716eddfe79b401135aff53e4cbf863df7e889246b30345caefc471dab6bcead8dcf8620e6953b96067cc646979b2bf42cf4a166052c06b6d11900eaf72b5d7d2fa803f9fc0d7f11db8b71da88bdb9194132aff821760375bb8eef4226a0dfae2a2631ed7752df801958ebc3825fe076c183955fba4114097c2b0b48499f01a27802a3eca22342cea1908fdcd19a647973a5329fb4fcb66bf83654815f3ba4f537c680a4c3ca56c54f5e15e5dc14e00419685a761ede723a8a56e2fe4f6c40686f5b61e9a7888be13f04208306e1533641d1a8406a28e021f7c17ff08ffebc0cd249556d1c3c5855a2d10fb4930dfe013647f995a3336a0a2fd9a56ebf02d9daec1125841bad424b6c35be0eafe0b22e7a412d6a953b48e806296948b6134295cead1e279501376bcdaad365b74e9bb504812aec72024044e4a63d55144acb228ed4bde7f287e8f786bbeccf4c36eceeb5424e040de41d87985542858f91f105d2cbb513782acb5a065bd10842c243898c5c64673450c59794c2bf0479dca3d7cda577f2259dade8c9d4eae037f86a99ead44a16d8e5efa2e0acfbda074a3a487547e9084d67dcba5f14b656684e127378c6139bf7db35a3890f5733c006622cc41bce4548106d1ba16022de426042296f579ce01664638371b30a57b5b2b28794a6148b55187689fbfe8da021caea690217c76249d0d749e99027dedee2aaacf93e79ac187fdaba72a1a8b2a3fcc560649ca1c95de95e133d1ff987263c210ef3e4a486fb8353dfd0c8c477efb04ef674e9a7f5cfc8ae0c03b0e890a8129bf9560c077b947a483452f43022bd07f0968fb082cce7de4efb54d1fa214dba2467ec7e3efb8e1d68a1e34678e16af7ce8bd59ecc974ff7022de0b7cd7e8bf0ea31bc26fadcff3fc7f104d893128758b427c5741b1e7dae236f1c64c1842d568a0ce98288586074f497a22612e695eec76852d179eff3350abc60ca4664d1e33447973f5cc40efbb7c2249353703d05a6602b3f1d0b5ce402dbbd2c93490c5195e17ee9bab426313338122ba9ad9b028855e977e7f4628d7db1db8ffe1072f32733ce3bfc8d551f091225cb179c456b59e38338d31f607b9492b1ceff0f0a82d040418b5a7d1b041921e40cdacd9cda63a62d9fc5ffa6e2924279d3e1761756e8b4ab0b9b1e8fb0d84fc5e2bf104f612bb24490d07fa88081584bd9d1f9c9510b3d42429e03af6ef5ee989145ffa5237cab721ab2ddba85614aa373dc23cb346363a495cdd5a1a8eb4e88b2c9fe9b2c45142a057c0e08f799d4e1956c9631254e9c2cb0a21bb868b593279de137781d121628ec054bb07dd810e28a974989359e60252be764f58347a0487de55f13e80f4019fb58399662f8611cc084b0123212f45fd241fd351d624934ba48647503316875bb4efe3ce09c44fecd937741eb153bb9cfc6aeb1691dab9d92b7a09e1087ac893c6530daf946f4abe4c74cebab732d7a466daf9c7f63b1cec8ecd6e72e861b5126dc6b3c271bd7c32fb06a0084feac450f2fabbcbdc622813d2b134f83616e3f4c0834d0cb9ddb399f6c2b86c81d2b50e221b06f32c2536f453e77f0ad5aad1c0c719f4cfc3527b939397722f55b00bf3c75ca379767df71388bd4ec6e745e38d7730052e3477b837eac64bad8dbb88f4afca1bda7232d65370d3eac30be9b53a09807ef38a1bf1ef8f28c664d150177bbfe2294b2426395350394ed3625c8e946febf6b988c47569c50ca5dcecd52a5b825dd75096ecf54c5736d170ed3d9103787d2b7a6e4e5ab5a23bcac9bcd6ab3b1fae0aad4966a06d22c3cb83aad479838ebd8bab6c8dfefaebb034780a37f929ee694694f901ae37d92d8c2d0ffddde6d1b51544a2c4a182a6140d117d506194608a1ff45e70e148b5db91e071fffc9ab14d29c35192a763d836d3a42aac171bcecc9d4680335c6d9fdcce6ee765a45eb1a61f2997e5e65e7c00b31db0eb271d1881b635a64416ea73c63e1f6f2696d4aaecb40b19e4711cf4c2a0c6be30034a43ad40e6e4429184389b8bec87fa41726797fd27720cdf0fa492cb9332cb79a840cf4b9a8fb73a06b0faf6f264d009522e1cfdef47fad201e90cc3545c014f2fd382aec15a550acae4b7de8442ea6148ec02fae8424c3abe2b9cb7c2d16122b3c490760220819fcca50c5f6c946061d9bf533dad3310d39e5ade1ef015755c489c8dc6ab2d1e83684c5b7a3a966ac9e46a6e8458bf9d65c801c40a6dadced1770a1bc21675fa98bcc32e746d726b9163330651e3efcd6b17d2990bfc82bb1170d95323e61c5b6c174c80b6a7d7bb49c0709896276894d1f5587bcb2cc7de5f5fc75d5e5d690d019ef0445ce0345033b1bedee379cfa4f5083d9cfed1483913ea8804b5c383496138c11e5ca0cfead3e3384e51ce5d2331a0ebbfd89e092d1e759b4c2720a7e3c99c01f16222c5b669e180a7ed5d169c9aea5de5ac7af139a4ef1bf5e5d5c4b8f297b41359eb68412f608da873cf5d02d59d1e69c5dede1ec071a678b3dbb965476ee8f970076021b3a884ed86565178fa04515f9900929260ac7d888e6136c944d1d964e1b595652b178e3a116829205425103c3e1c2651f2c70a38d029dbc18bb339cb1737830de9b183919f66256a033da7bced7044da4072616fb150e7102fbb59a8263fce6e23b02f870f9a6a220edfdff54fd6bbd68e3731a74a4fe1784f5b13d09625bcd79186aed038097d060dd227924439d5e1bed60379cda50c0ce783d0b54e4ba9dc990b7c3508caf3a1b66b4e0fdf07d2cb8ffcc18b34aec7e0ac7ab51a6cc4c9349c2f559df7dd876617109d7fbfa08f50494a9d8942de6b8d39ef51670f024faa15ac87beca9b3e57d67295816f3abf4588b1849fa98c0c67a8e7b1e983a7c5d4571a6879269b1e20efe08b08e1ebf5d8bbe064981caaf187c709823bc4a7c5a8e5799085f65bd389947ab597e1ce068f5efda159863849bf3ebf2c4919c7c3ee36c96226ebe09fd7d6494e7497de5c17e68e6d8fd69386459810a6180f0556270389fee2f4d23e4148685693b080c0fb867675ba9d9144607a27ed4c322cd844d7f1586f5c4fdb0bb0782dbb5bbb2c9f3420f1236a933b990da3b694943b8baa6f8157e691c34b1d6e9d0bcbd355379f98eeae3acfdee9aad35eff3abfa11eb8aa2c4f0ff9f81ffbb4da7d891cd819d3b9143e47c7d22cfebdb27229c0ba2a91dcfc63aa2644cd7c47611c6f48f44c7b8a0e069a295b0dd10c9dc1b38885bafcda4a71cbb1cee40d104edf366b9aebdd2fc1123b8ea1269adac460fd4f6ffdeffebaffb60c784b409cef98d871cb676bdcc9e3617fc04f9dd92f9326e6fc91cf72ebfd1e286ba4daf3a25a4cadb65d1e95e8ddf6e57448f0eefbfe2388a9dcb2bdaf3297f4bfff88c2909004684b5c6879a0e5838434cf9cffa8d114dbfcc42f60fda1b6c4d6a869fe9eabbf64f1ff089fc86a23da7d65cf8385056a1d3ee03e552084e0a882ffa1146c41175ec78d24dd7dd2fd00e8f8d3c9eb8f186c1a73bcca80d6334306afed6aeb377d45245137b9ea216ff64135a6ced56772b8941abb07d7f56e07304d17c8b65cb3fda442af4dad220da4cb8a4d8d0e71b113cf47a948ac7d718187d8af47de5f0947afc5c4070a291437b4e358fcd25229c150dfc70bb12fad3151005d684e478e1655346d7d694c0c4a3b174390c10ca5fc86b8a478595134abd6d0a1815944a8696230f1b914adcc9aa573febe45841d0e03d5827b1dbb3c3bc07deb08a32e0a6e633f7cbc47c93a9822fa271de3169f434582f01db23d84dc8b9f4ea63b7274a3404aaa91c510138adae1c50dd94c4cfeafa16c36bc29ebf1682a51303da6a34f490896f541ace2f117323a0c79c5b03f9c6658c3e4d731ac26043d4d0e4cd44005fef69371e0fb99237185294257aeaaa1a2f09da952379bc364cf4b09e47afc32dfc3548fbc1e549b4c7f40906af73a0d5b67a1908e0ac87dd724d024f59fef4b660b82ebc928998552b69eb55ac7a101d500925209ce11e7da9693cb15d610f1f36bce1937bd2c8f1be89c5cfe6a8e33486951a658eed7c908846e9fa533a4ef4b5439e5a20db7caace6eb1d8f11875f255a890fcbf4357d981c69552134828afb0be63c56b0cdc96d826e6425f05cf819c0b4b07e0e301f29fd4d436aafdebe12f505a833333b3c0ac4b8003014667ca275fb51c064df3b84c31e8c6e5c3fcbc30e735556c58f9dca4336af220686e92d857a5cd28aa230e2081115d3ab4b8c9a74cee0e472cf2005cbe55f6bf58d6c697d661a0d9ce876282f13b7d30fccfa3d57cd17ae709f4aceca847239d825ab3b2b536bdfdeb9badbd5091fbb11862a82cfd06716efa82562e7827c816ad3830e684e3eb329a64db62fb878548cff3ec9a1348dcd32d11df341f199f498abb42e2e888546db5fe8202b1aa2b2272b9d58026ebc7ecd29149095b02b3300e813d200ced9afc7cbd6141828f2c7ae9fd2967a9cfbc7ee68d9a70b3000aa49c3d12c1c49da7a851619ee0f3451dc13dea9ee91799aa45b1e28c2229533be728ef30ae539af39b004a3554df81f60d76b1094e02051fc7037764a624f9379de3925e03c6da2141a8ef0ed2776201829ad752c50f26285675691a03f6c4b02bd20f65957f515d06513e07f9238c14ebd64bbb981e87c1a2660fc7bc82272103e81255bc638285ea363fc2740605a594b5329a6ea0a7f446b6e5a9dcf8178f5efa09532818a78e01b6657334662babf7a6507a0cdc0effb9fb7d38b81f3e8431e2e6887","isRememberEnabled":true,"rememberDurationInDays":"1","staticryptSaltUniqueVariableName":"413b2808afe2d242244726ad764b994b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
